[{"title":"AMM的数学原理","path":"/2025/07/24/AMM的数学原理/","content":"1. 恒定乘积公式$$ x \\cdot y k$$ x：池中代币 A 的数量（如 SUI） y：池中代币 B 的数量（如 USDC） k：池的恒定乘积（表示池的总流动性） 任意交易必须满足公式 $x \\cdot y k$，代币 A 和 B 的比例变化会调整价格，但 k 在没有流动性变动的情况下保持不变。 2. 价格计算AMM 中的代币价格由两种代币的比例决定 A 的价格（以 B 为单位）： $$ P_A \\frac{y}{x}$$ B的价格（以A为单位）： $$P_B\\frac{x}{y}$$ 价格与池中代币的比例直接相关,每次交易都会改变池中代币的比例，从而调整价。 3. Swap用户通过往池中支付一种代币，来换取另一种代币。 假设用户使用B来购买A，即支付 $\\Delta y$ 个 B 来买入 $\\Delta x$ 个 A，交换之后，交易池中的A和B的数量更新为 $x{\\prime}$ , $y\\prime$ $$ x{\\prime} x - \\Delta x, \\y{\\prime} y + \\Delta y$$ 根据恒定乘积公式 $$ x{\\prime} \\cdot y{\\prime} x\\cdot y k$$ 计算swap过程中的数量变化 $$ (x - \\Delta x) \\cdot (y + \\Delta y) k$$ 可计算得到用户输入数量 $\\Delta y$ 的B后，得到的 $\\Delta x$数量的A $$ \\Delta x x - \\frac{k}{y + \\Delta y}$$ 交易之后价格产生变化 $$P_A{\\prime} \\frac{y{\\prime}}{x{\\prime}}$$ 滑点定义为交易前后价格的相对变化 $$ \\text{slip point} \\frac{P_A{\\prime} - P_A}{P_A}$$ 反之，如果使用A换B，那么根据公式 $$ (x + \\Delta x) \\cdot (y - \\Delta y) k$$ 用户得到的B的数量为 $$ \\Delta y y - \\frac{k}{x + \\Delta x}$$ 4. 添加流动性流动性提供者向池中增加代币 A 和 B，流动性乘积 k 随之变化。 流动性必须按当前比例添加 $$ \\frac{\\Delta x}{x} \\frac{\\Delta y}{y}$$ 添加流动性后，新的池状态： $$ x{\\prime} x + \\Delta x, \\quad y{\\prime} y + \\Delta y$$ 添加流动性之后，K值会变大： $$ k{\\prime} x{\\prime} \\cdot y{\\prime}(x + \\Delta x) \\cdot (y + \\Delta y)$$ 5. 移除流动性流动性提供者从池中移除代币 A 和 B，流动性乘积 k 减小。 $$ \\frac{\\Delta x}{x} \\frac{\\Delta y}{y}$$ 移除流动性后，池中的代币数量变化: $$ x{\\prime} x - \\Delta x, \\quad y{\\prime} y - \\Delta y$$ 新的恒定乘积: $$ k{\\prime} x{\\prime} \\cdot y{\\prime}(x - \\Delta x) \\cdot (y - \\Delta y)$$ 6. 无常损失在 AMM 池中提供流动性时，与直接持有代币相比，因价格变化而导致的潜在收益损失即为无常损失。 $P_0$：代币 A 相对于 B 的初始价格，即 $P_0 \\frac{y}{x}$ $P_1$：价格变化后代币 A 的新价格，即 $P_1 \\frac{y{\\prime}}{x{\\prime}}$ 价格变化比例为$r:$ $$ r \\frac{P_1}{P_0}$$ 在池外直接持有代币的价值： $$ V_{\\text{HODL}} x_0 \\cdot P_0 + y_0$$ 在池内提供流动性的价值： $$ x_{\\text{LP}} \\sqrt{\\frac{k}{P_1}}, \\quad y_{\\text{LP}} \\sqrt{k \\cdot P_1}$$ 提供流动性后的总价值为 $$ V_{\\text{AMM}} x_{\\text{LP}} \\cdot P_1 + y_{\\text{LP}}$$ LP 在 AMM 中提供流动性与直接持有代币价值的相对损失： $$ IL \\frac{V_{\\text{AMM}} - V_{\\text{HODL}}}{V_{\\text{HODL}}}$$ 简化公式得到: $$ \\text{无常损失（IL）} 2 \\cdot \\sqrt{r} \\cdot \\frac{1}{r+1} - 1$$ r 1（价格不变）时，无常损失为 0，r 偏离 1 越多，无常损失越大。","tags":["区块链","交易"]},{"title":"《形式语言理论在安全领域的应用》翻译","path":"/2025/07/24/《形式语言理论在安全领域的应用》翻译/","content":"[TOC] We present an approach to improving the security of complex, composed systems based on formal language theory, and show how this approach leads to advances in input validation, security modeling, attack surface reduction, and ultimately, software design and programming methodology. We cite examples based on real-world security flaws in common protocols representing different classes of protocol complexity. We also introduce a formalization of an exploit development technique, the parse tree differential attack, made possible by our conception of the role of formal grammars in security. These insights make possible future advances in software auditing techniques applicable to static and dynamic binary analysis, fuzzing, and general reverse-engineering and exploit development. 我们提出了一种基于形式语言理论的方法，用于提升复杂组合系统的安全性；并阐述了该方法如何推动输入验证、安全建模、攻击面缩减，以及最终在软件设计与编程方法论方面的进步。我们引用了基于常见协议中真实安全漏洞的实例，这些协议代表了不同复杂度的协议类别。此外，基于我们对形式语法在安全中所扮演角色的构想，我们引入了一种漏洞利用开发技术的形式化描述——语法树差分攻击（parse tree differential attack）。这些洞见为未来软件审计技术的进步铺平了道路，这些技术可应用于静态与动态二进制分析、模糊测试（fuzzing）、以及通用的逆向工程与漏洞利用开发。 Our work provides a foundation for verifying critical implementation components with considerably less burden to developers than is offered by the current state of the art. It additionally offers a rich basis for further exploration in the areas of offensive analysis and, conversely, automated defense tools and techniques. 我们的工作为验证关键实现组件奠定了基础，相比现有技术，显著减轻了开发人员的负担。此外，该工作也为攻击性分析以及（与之相对的）自动化防御工具与技术领域的进一步探索提供了丰富的基础。 This report is divided into two parts. In Part I we address the formalisms and their applications; in Part II we discuss the general implications and recommendations for protocol and software design that follow from our formal analysis. 本报告分为两个部分。第一部分阐述形式化方法及其应用；第二部分则讨论基于我们形式化分析得出的、关于协议与软件设计的总体影响与建议。 1. 介绍 Composition is the primary engineering means of complex system construction. No matter what other engineering approaches or design patterns are applied, the economic reality is that a complex computing system will ultimately be pulled together from components made by different people and groups of people. 组合是构建复杂系统的主要工程手段。无论采用何种其他工程方法或设计模式，现实情况是，一个复杂的计算系统最终都将由不同人员或团队开发的组件组装而成。 For the traditional division of a system into hardware, firmware, and software, and of software into device drivers, generic OS kernel and its sub-layers, and various application software stacks and libraries the fact of this composition is so obvious that it is commonly dismissed as trivial; how else can one build modern computers and modern software if not in a modular way? Moreover, modularity is supposed to be good for security and reliability, because without them programming would be intractable. 在传统系统分层（硬件、固件、软件）以及软件分层（设备通用操作系统内核及其子层、各类应用软件栈与库）的背景下，这种组合的事实如此显而易见，以至于常被视为微不足道而被忽略；若非采用模块化方式，还能如何构建现代计算机与软件？此外，模块化理应有益于安全性与可靠性，因为缺乏安全性与可靠性，编程将变得难以处理。 However, doing composition securely has emerged as the primary challenge to secure system construction. Security practitioners know that interfaces are attack targets of choice, and that vulnerabilities are often caused by unexpected interactions of features across components; yet the reasons for this are elusive (except perhaps the attacker’s desire for reliable execution of their exploits, which leads them to target the best-described parts of systems with tractable state; still, this does not explain our collective inability to design systems without unwanted feature interactions). 然而，实现安全的组合已成为构建安全系统的核心挑战。安全从业者深知接口是攻击者的首选目标，而漏洞往往源于组件间功能的非预期交互。但其深层原因仍难以捉摸（或许可归因于攻击者追求漏洞利用的可靠执行，故倾向于针对系统状态可控、文档完备的部分，但这仍无法解释为何我们始终难以设计出完全规避非预期功能交互的系统）。 In this paper we argue that we need a new, stronger theoretic understanding of computational units’ composition and of their underlying properties that make it empirically hard to “get it right”, i.e., design systems without vulnerabilities caused by composition. 在本论文中，我们主张需要对计算单元的组成及其底层属性建立一种新的、更强的理论解释，正是这些属性使得实践中难以“实现完美”——即设计出不存在由组合引发漏洞的系统。 We show that there are strong computational-theoretic and formal language-theoretic reasons for the challenges of secure composition, and chart design principles to reduce these challenges. In particular, we show that the hard challenges of safe input handling and secure composition arise due to the underlying theoretically hard or unsolvable (i.e., undecidable) problems that certain protocol designs and implementations essentially require to solve in order to secure them. We posit that the (unwitting) introduction of such problems in the design stage explains the extreme propensity of certain protocols and message formats to yield a seemingly endless stream of “0-day” vulnerabilities despite efforts to stem it, and the empirical hopelessness of “fixing” these protocols and message formats without a fundamental redesign. 我们揭示了安全组合面临的挑战，存在深层的计算理论层面及形式语言理论层面的原因，并规划了降低这些挑战的设计原则。具体而言，安全输入处理与安全组合面临的严峻挑战，源于某些协议设计与实现本质上必须解决的底层理论难题——这些问题在理论上本就难以解决甚至无解（即不可判定）。我们认为，设计阶段（无意的）引入此类问题，导致特定协议和消息格式极易衍生看似无止境的零日漏洞问题（尽管人们努力遏制）。且在缺乏根本性重构的情况下，对这些协议与消息格式进行“修补”在实践中是徒劳的。 We also chart ways to avoid such designs prone to turning into security nightmares for future Internet protocols. Empirically, attempts to solve an engineering problem that implies a “good enough” (or “80%20%”) solution to the underlying undecidable theory problem are doomed to frustration and failure, which manifests in many ways, such as no amount of testing apparently sufficing to get rid of bugs, or the overwhelming complexity and not-quite-correct operation of the automation or detection tools created to deal with the problem. Thus, avoidingsuch problems in the first place (at the design stage) saves both misinvestment of programming effort and operational costs. 我们还规划了避免此类设计的路径，以防止其演变为未来互联网协议中的安全隐患。实践表明，若工程问题本质上需解决不可判定的理论问题，那么试图以“足够好”（如“80%对比20%”）的方案应对时，也往往以失败告终。其表现形式多样：例如无论多少测试均无法根除缺陷，或为应对该问题开发的自动化检测工具复杂程度极高且运行并非完全正确。因此，在设计阶段预先规避此类问题，既可避免编程资源的过度投入，也能降低运营成本。 Our argument focuses on the application of fundamental decidability results to the two basic challenges of composed and distributed system construction due to communication between components: safely accepting and handling inputs in every component, and identical interpretation of messages passed between components at every endpoint. In particular, we consider the following two perspectives on composition: 我们的论点主要集中在将基本可判定性结果应用于由组件间通信引起的复合和分布式系统构建的两个基本挑战：在每个组件中安全地接受和处理输入，以及在每个端点上对组件间传递的消息进行相同的解释。特别是，我们考虑了以下两个关于组合的观点： Single-component perspective: A component in a complex system must accept inputs or messages across one or more interfaces. This creates an attack surface, leveraged by an absolute majority of exploitation techniques. We discuss hardening the attack surface of each component against malicious crafted inputs, so that a component is capable of rejecting them without losing integrity and exhibiting unexpected behavior— in short, without being exploited. Multi-component perspective: As components exchange messages, they must ensure that, despite possible implementation differences, they interpret the messages identi-cally. Although this requirement appears to be trivially necessary for correct opera-tion, in reality different implementations of a protocol by different components produce variations, or mutually intelligible dialects, with message semantic differences masked(and therefore ignored) in non-malicious exchanges. A smaller but important class of attack techniques leverages such differences, and can lead to devastating attacks such as those on X.509 and ASN.1 discussed in this paper. 单组件视角：复杂系统中的一个组件必须通过一个或多个接口接受输入或消息。这会创建一个攻击面，被绝大多数利用技术所利用。我们讨论了如何加固每个组件的攻击面以抵御恶意制作的输入，从而使组件能够在不失去完整性和表现出意外行为的情况下拒绝这些输入——简而言之，不会被利用。 多组件视角：当组件交换消息时，它们必须确保尽管可能存在实现差异，但它们对消息的解释是相同的。虽然这个要求看起来对于正确操作来说是微不足道的，但实际上不同组件对协议的不同实现会产生变化，或者相互可理解的方言，其中消息语义差异在非恶意交换中被掩盖（因此被忽略）。一小部分但重要的攻击技术利用了这种差异，并可能导致毁灭性的攻击，例如本文讨论的对X.509和ASN.1的攻击。 The importance of these requirements is an empirical fact of the Internet security experience(cf.[1, 2, 3]), which our paper puts in solid theory perspective. We then elaborate the general principles of protocol design that follow from our analysis. 这些要求的重要性是互联网安全经验的实证事实（参见[1, 2, 3]），我们的论文从坚实的理论角度进行了阐述。然后，我们详细阐述了遵循我们分析的协议设计的一般原则。 本文结构 Our presentation consists of two parts. In Part I we make the case for formal language-theoretic approach to security, and show the direct relevance of various formalisms to prac-tical, state-of-the-art classes of exploits and defences. In Part II we change tack and address protocols designers, developers, and security auditors with a set of recommendations derived from our formal analysis but formulated informally and accessibly. Readers interested in our recommendations may skip the formal arguments in Part I and go straight to Part II’s for their summary. 我们的报告分为两部分。在第一部分，我们为安全的正式语言理论方法进行辩护，并展示各种形式主义与实践中的、最先进的攻击和防御类别的直接相关性。在第二部分，我们改变策略，向协议设计者、开发者和安全审计员提出一系列建议，这些建议源自我们的正式分析，但以非正式且易于理解的方式表述。对我们的建议感兴趣的读者可以跳过第一部分的形式论证，直接阅读第二部分的总结。 We start with the motivation of our approach in Section 2 and review the necessary background formalisms in Section 3. 我们在第2节中介绍了我们的方法的动机，并在第3节中回顾了必要的背景形式。 Then in Section 4 we explain how these general formalisms apply to exploitation of computing systems, and illustrate this application for several well-known classes of practical exploitation techniques. In doing so, we connect the corresponding classes of attacks with formal language properties of targeted data structures, which provides a novel and definitive way to analyze various suggested defences. 在第5节中，我们展示了如何应用形式语言理论技术来实现严格的、非启发式的输入验证。我们从SQL验证开始讨论，但也表明同样的方法适用于其他上下文无关的语言，如PKCS#1（在第5.2节中，我们证明了PKCS#1确实是上下文相关的）。我们还讨论了先前验证方法中的缺陷，并说明为什么这些缺陷对实际安全至关重要。 The discussion of flaws leads to us Section 6, in which we present a new technique for security analysis of differences between mutually intelligible language dialects that arise from implementation differences. This technique, Parse Tree Differential Analysis, proved a powerful tool to enhance code auditing and protocol analysis. 对缺陷的讨论引导我们进入第6节，在这一节中，我们提出了一种新的技术，用于分析因实现差异而产生的相互可理解语言方言之间的差异的安全性分析。这种技术，即解析树差异分析，被证明是一种增强代码审计和协议分析的强大工具。 In Section 7, we show that the challenges and failures of IDSIPS, arguably the most common form of security composition, can be explained via language-theoretic computa-tional equivalence. We conclude Part I with an outline of future work. 在第7节中，我们展示了IDSIPS的挑战和失败，可以说是安全组合最常见的形式，可以通过语言理论计算等价性来解释。我们以对未来工作的概述结束了第一部分。 In Part II we recap the observations of Part I and formulate several principles that follow from our analysis in the preceding sections, and discuss their corollaries for designing and implementing protocols securely. 在第二部分中，我们回顾了第一部分的观察结果，并根据前几节的分析制定了几个原则，讨论了它们对安全设计和实施协议的推论。 第一部分：安全与形式语言理论为什么安全需要形式语言理论 We posit that input verification using formal language theoretic methods — whether simply verifying that an input to a protocol constitutes a valid expression in the protocol’s gram-mar or also verifying the semantics of input transformations — is an overlooked but vital component of protocol security, particularly with respect to implementations. Simply put, a protocol implementation cannot be correct unless it recognizes input correctly, and should be considered broken. 我们提出，使用形式语言理论方法进行输入验证——无论是简单地验证协议的输入是否构成协议语法中的有效表达式，还是验证输入转换的语义——是协议安全的一个被忽视但至关重要的组成部分，特别是在实现方面。简而言之，除非协议实现能够正确识别输入，否则它就无法正确运行，并应被视为有缺陷的。 Formal software verification seeks to prove certain safety(“nothing bad happens”) and liveness(“something good happens, eventually”) properties of program computations: if ev-ery computation a program can perform satisfies a particular property, the program is safe(or, respectively, live) with respect to that property[4]. Program verification in the general case is undecidable, and although many approaches to falsification and verification of properties have been developed, unsolved and unsolvable problems with the scalability and completeness of algorithmic verification have prevented formal correctness from displacing testing and code auditing as the industry gold standard for software quality assurance[5]. However, programs that implement protocols — that is to say, routines that operate over a well-defined input language1 — share one characteristic that can be leveraged to dramati-cally reduce their attack surfaces: their input languages can — and, we posit, should — in general be made decidable and can be decided in a tractable fashion. We show that this requirement of being well-specified and tractably decidable is in fact a crucial pre-requisite of secure design and, in fact, its violation is the source of much of the present-day computer insecurity. 正式软件验证旨在证明程序计算的某些安全（“不会发生坏事”）和活性（“最终会发生好事”）属性：如果程序可以执行的每个计算都满足特定属性，那么该程序在该属性方面是安全的（或分别具有活性）[4]。一般情况下的程序验证是不可判定的，尽管已经开发了许多属性的反证和验证方法，但算法验证的可扩展性和完整性的未解决和无法解决的问题阻碍了正式正确性取代测试和代码审计作为软件质量保证的行业黄金标准[5]。然而，实现协议的程序——也就是说，操作在明确定义的输入语言上的例程——共享一个特性，可以利用这个特性来显著减少它们的攻击面：它们的输入语言通常可以被制成可判定的(我们主张也应该这么做)，并且可以以一种可行的方式进行判定。我们表明，这种要求是良好指定和可行可判定的，实际上是安全设计的关键先决条件，事实上，其违反是当今计算机不安全的主要来源。 Inputs to system components such as web browsers, network stacks, cryptographic pro-tocols, and databases are formally specified in standards documents, but by and large, implementations’ input handling routines parse the languages these standards specify in an ad hoc fashion. Attacks such as the Bleichenbacher PKCS#1 forgery[6, 7] show what can happen when an ad hoc input-language implementation fails to provide all the prop-erties of the input language as actually specified. In more recent work[8], we have shown that variations among implementations can be exploited to subvert the interoperation of these implementations, and that ambiguity or underspecification in a standard increases the chances of vulnerability in otherwise standards-compliant implementations. 系统组件的输入，如网络浏览器、网络堆栈、加密协议和数据库，在标准文档中被正式规定，但总的来说，实现的输入处理程序以一种临时的方式解析这些标准所规定的语言。诸如Bleichenbacher PKCS#1伪造[6, 7]等攻击表明，当一个临时的输入语言实现未能提供实际指定的输入语言的所有属性时会发生什么。在最近的工作[8]中，我们已经证明，实现之间的差异可以被利用来破坏这些实现的互操作性，并且标准中的模糊或未充分规定会增加其他符合标准的实现中出现漏洞的可能性。 On this basis, we argue that “mutually intelligible dialects” of a protocol cannot make guarantees about their operation because the problem $Equivalent(L(G) L(H))$ is unde-cidable when G and H are grammars more powerful than deterministic context-free[9, 10]. We also observe that systems that consist of more than one component have inherent, de facto “design contracts” for how their components interact, but generally do not enforce these contracts; SQL injection attacks(hereafter SQLIA), for instance, occur when an at-tacker presents a database with an input query that is valid for the database in isolation, but invalid within the context of the database’s role in a larger application. 在此基础上，我们认为协议的“相互可理解方言”无法对其操作做出保证，因为当G和H是比确定性上下文无关更强大的语法时，问题 $Equivalent(L(G) L(H))$ 是不可判定的[9, 10]。我们还观察到，由多个组件组成的系统具有固有的、事实上的“设计合同”，规定了其组件如何交互，但通常不强制执行这些合同；例如，SQL注入攻击（以下简称SQLIA）发生在攻击者向数据库提供一个在孤立状态下对数据库有效的输入查询，但在数据库在更大应用程序中的角色背景下无效的情况下。"},{"title":"notedemo","path":"/2025/07/18/notedemo/","content":"这是一篇笔记，用于测试的"},{"title":"page03","path":"/2025/07/17/page03/","content":"二级comments: enable: true # 指定的插件，需要同时设置对应插件的必要参数 # The specified plugin needs to set the necessary parameters at the same time # Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis type: giscus {这是一个友情链接} 普通的没有勾选的复选框 普通的已勾选的复选框 显示为加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框 $$\\sum_{i0}^n i^2 \\frac{(n^2+n)(2n+1)}{6}$$ graph LR A(Section A) -->|option 1| B(Section A) B -->|option 2| C(Section C) 这是使用markdown 默认的引用格式 这是使用 blockquote 标签的例子 热门话题 特别引用 X不带摘要的样式： https://matrixye.github.io/%3Chttps:/hexo.io/docs/%3E X带摘要的样式： https://matrixye.github.io/%3Chttps:/hexo.io/docs/%3E 探索 O1 2077年的小目标：完成 Volantis 6.0 并发布上线 来自2077年末的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 正常 99% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 支持嵌套插入图片等其它简单组件 风险 0% 这是 高斯模糊 标签 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试： ⌘ + D 表情包 投票Stellar 是最好的 hexo 主题吗？ 0 0 时间线第一步：打开 GitHub打开 Stellar 的 GitHub 页面。第二步：点击 Star如果发现右上角的 Star 还没点亮，就点亮它！ 代码def hello(): print(hello world!) 多标签页图片代码块表格let x = 123print(hello world) a b c a1 b1 c1 a2 b2 c2","tags":["区块链","bitcoin"]},{"title":"firstpage","path":"/2025/07/17/firstpage/","content":"标题测试文档 二级标题 aaaa bbbb cccc dedede dedede dedede thisi is XXXXX","tags":["bitcoin"]},{"title":"Hello World","path":"/2025/07/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new posthexo new My New Post More info: Writing Run serverhexo server More info: Server Generate static fileshexo generate More info: Generating Deploy to remote siteshexo deploy More info: Deployment","tags":["other"]}]