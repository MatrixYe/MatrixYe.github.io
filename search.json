[{"title":"AMMçš„æ•°å­¦åŸç†","path":"/2025/07/24/AMMçš„æ•°å­¦åŸç†/","content":"1. æ’å®šä¹˜ç§¯å…¬å¼$$ x \\cdot y k$$ xï¼šæ± ä¸­ä»£å¸ A çš„æ•°é‡ï¼ˆå¦‚ SUIï¼‰ yï¼šæ± ä¸­ä»£å¸ B çš„æ•°é‡ï¼ˆå¦‚ USDCï¼‰ kï¼šæ± çš„æ’å®šä¹˜ç§¯ï¼ˆè¡¨ç¤ºæ± çš„æ€»æµåŠ¨æ€§ï¼‰ ä»»æ„äº¤æ˜“å¿…é¡»æ»¡è¶³å…¬å¼ $x \\cdot y k$ï¼Œä»£å¸ A å’Œ B çš„æ¯”ä¾‹å˜åŒ–ä¼šè°ƒæ•´ä»·æ ¼ï¼Œä½† k åœ¨æ²¡æœ‰æµåŠ¨æ€§å˜åŠ¨çš„æƒ…å†µä¸‹ä¿æŒä¸å˜ã€‚ 2. ä»·æ ¼è®¡ç®—AMM ä¸­çš„ä»£å¸ä»·æ ¼ç”±ä¸¤ç§ä»£å¸çš„æ¯”ä¾‹å†³å®š A çš„ä»·æ ¼ï¼ˆä»¥ B ä¸ºå•ä½ï¼‰ï¼š $$ P_A \\frac{y}{x}$$ Bçš„ä»·æ ¼ï¼ˆä»¥Aä¸ºå•ä½ï¼‰ï¼š $$P_B\\frac{x}{y}$$ ä»·æ ¼ä¸æ± ä¸­ä»£å¸çš„æ¯”ä¾‹ç›´æ¥ç›¸å…³,æ¯æ¬¡äº¤æ˜“éƒ½ä¼šæ”¹å˜æ± ä¸­ä»£å¸çš„æ¯”ä¾‹ï¼Œä»è€Œè°ƒæ•´ä»·ã€‚ 3. Swapç”¨æˆ·é€šè¿‡å¾€æ± ä¸­æ”¯ä»˜ä¸€ç§ä»£å¸ï¼Œæ¥æ¢å–å¦ä¸€ç§ä»£å¸ã€‚ å‡è®¾ç”¨æˆ·ä½¿ç”¨Bæ¥è´­ä¹°Aï¼Œå³æ”¯ä»˜ $\\Delta y$ ä¸ª B æ¥ä¹°å…¥ $\\Delta x$ ä¸ª Aï¼Œäº¤æ¢ä¹‹åï¼Œäº¤æ˜“æ± ä¸­çš„Aå’ŒBçš„æ•°é‡æ›´æ–°ä¸º $x{\\prime}$ , $y\\prime$ $$ x{\\prime} x - \\Delta x, \\y{\\prime} y + \\Delta y$$ æ ¹æ®æ’å®šä¹˜ç§¯å…¬å¼ $$ x{\\prime} \\cdot y{\\prime} x\\cdot y k$$ è®¡ç®—swapè¿‡ç¨‹ä¸­çš„æ•°é‡å˜åŒ– $$ (x - \\Delta x) \\cdot (y + \\Delta y) k$$ å¯è®¡ç®—å¾—åˆ°ç”¨æˆ·è¾“å…¥æ•°é‡ $\\Delta y$ çš„Båï¼Œå¾—åˆ°çš„ $\\Delta x$æ•°é‡çš„A $$ \\Delta x x - \\frac{k}{y + \\Delta y}$$ äº¤æ˜“ä¹‹åä»·æ ¼äº§ç”Ÿå˜åŒ– $$P_A{\\prime} \\frac{y{\\prime}}{x{\\prime}}$$ æ»‘ç‚¹å®šä¹‰ä¸ºäº¤æ˜“å‰åä»·æ ¼çš„ç›¸å¯¹å˜åŒ– $$ \\text{slip point} \\frac{P_A{\\prime} - P_A}{P_A}$$ åä¹‹ï¼Œå¦‚æœä½¿ç”¨Aæ¢Bï¼Œé‚£ä¹ˆæ ¹æ®å…¬å¼ $$ (x + \\Delta x) \\cdot (y - \\Delta y) k$$ ç”¨æˆ·å¾—åˆ°çš„Bçš„æ•°é‡ä¸º $$ \\Delta y y - \\frac{k}{x + \\Delta x}$$ 4. æ·»åŠ æµåŠ¨æ€§æµåŠ¨æ€§æä¾›è€…å‘æ± ä¸­å¢åŠ ä»£å¸ A å’Œ Bï¼ŒæµåŠ¨æ€§ä¹˜ç§¯ k éšä¹‹å˜åŒ–ã€‚ æµåŠ¨æ€§å¿…é¡»æŒ‰å½“å‰æ¯”ä¾‹æ·»åŠ  $$ \\frac{\\Delta x}{x} \\frac{\\Delta y}{y}$$ æ·»åŠ æµåŠ¨æ€§åï¼Œæ–°çš„æ± çŠ¶æ€ï¼š $$ x{\\prime} x + \\Delta x, \\quad y{\\prime} y + \\Delta y$$ æ·»åŠ æµåŠ¨æ€§ä¹‹åï¼ŒKå€¼ä¼šå˜å¤§ï¼š $$ k{\\prime} x{\\prime} \\cdot y{\\prime}(x + \\Delta x) \\cdot (y + \\Delta y)$$ 5. ç§»é™¤æµåŠ¨æ€§æµåŠ¨æ€§æä¾›è€…ä»æ± ä¸­ç§»é™¤ä»£å¸ A å’Œ Bï¼ŒæµåŠ¨æ€§ä¹˜ç§¯ k å‡å°ã€‚ $$ \\frac{\\Delta x}{x} \\frac{\\Delta y}{y}$$ ç§»é™¤æµåŠ¨æ€§åï¼Œæ± ä¸­çš„ä»£å¸æ•°é‡å˜åŒ–: $$ x{\\prime} x - \\Delta x, \\quad y{\\prime} y - \\Delta y$$ æ–°çš„æ’å®šä¹˜ç§¯: $$ k{\\prime} x{\\prime} \\cdot y{\\prime}(x - \\Delta x) \\cdot (y - \\Delta y)$$ 6. æ— å¸¸æŸå¤±åœ¨ AMM æ± ä¸­æä¾›æµåŠ¨æ€§æ—¶ï¼Œä¸ç›´æ¥æŒæœ‰ä»£å¸ç›¸æ¯”ï¼Œå› ä»·æ ¼å˜åŒ–è€Œå¯¼è‡´çš„æ½œåœ¨æ”¶ç›ŠæŸå¤±å³ä¸ºæ— å¸¸æŸå¤±ã€‚ $P_0$ï¼šä»£å¸ A ç›¸å¯¹äº B çš„åˆå§‹ä»·æ ¼ï¼Œå³ $P_0 \\frac{y}{x}$ $P_1$ï¼šä»·æ ¼å˜åŒ–åä»£å¸ A çš„æ–°ä»·æ ¼ï¼Œå³ $P_1 \\frac{y{\\prime}}{x{\\prime}}$ ä»·æ ¼å˜åŒ–æ¯”ä¾‹ä¸º$r:$ $$ r \\frac{P_1}{P_0}$$ åœ¨æ± å¤–ç›´æ¥æŒæœ‰ä»£å¸çš„ä»·å€¼ï¼š $$ V_{\\text{HODL}} x_0 \\cdot P_0 + y_0$$ åœ¨æ± å†…æä¾›æµåŠ¨æ€§çš„ä»·å€¼ï¼š $$ x_{\\text{LP}} \\sqrt{\\frac{k}{P_1}}, \\quad y_{\\text{LP}} \\sqrt{k \\cdot P_1}$$ æä¾›æµåŠ¨æ€§åçš„æ€»ä»·å€¼ä¸º $$ V_{\\text{AMM}} x_{\\text{LP}} \\cdot P_1 + y_{\\text{LP}}$$ LP åœ¨ AMM ä¸­æä¾›æµåŠ¨æ€§ä¸ç›´æ¥æŒæœ‰ä»£å¸ä»·å€¼çš„ç›¸å¯¹æŸå¤±ï¼š $$ IL \\frac{V_{\\text{AMM}} - V_{\\text{HODL}}}{V_{\\text{HODL}}}$$ ç®€åŒ–å…¬å¼å¾—åˆ°: $$ \\text{æ— å¸¸æŸå¤±ï¼ˆILï¼‰} 2 \\cdot \\sqrt{r} \\cdot \\frac{1}{r+1} - 1$$ r 1ï¼ˆä»·æ ¼ä¸å˜ï¼‰æ—¶ï¼Œæ— å¸¸æŸå¤±ä¸º 0ï¼Œr åç¦» 1 è¶Šå¤šï¼Œæ— å¸¸æŸå¤±è¶Šå¤§ã€‚","tags":["åŒºå—é“¾","äº¤æ˜“"]},{"title":"ã€Šå½¢å¼è¯­è¨€ç†è®ºåœ¨å®‰å…¨é¢†åŸŸçš„åº”ç”¨ã€‹ç¿»è¯‘","path":"/2025/07/24/ã€Šå½¢å¼è¯­è¨€ç†è®ºåœ¨å®‰å…¨é¢†åŸŸçš„åº”ç”¨ã€‹ç¿»è¯‘/","content":"[TOC] We present an approach to improving the security of complex, composed systems based on formal language theory, and show how this approach leads to advances in input validation, security modeling, attack surface reduction, and ultimately, software design and programming methodology. We cite examples based on real-world security flaws in common protocols representing different classes of protocol complexity. We also introduce a formalization of an exploit development technique, the parse tree differential attack, made possible by our conception of the role of formal grammars in security. These insights make possible future advances in software auditing techniques applicable to static and dynamic binary analysis, fuzzing, and general reverse-engineering and exploit development. æˆ‘ä»¬æå‡ºäº†ä¸€ç§åŸºäºå½¢å¼è¯­è¨€ç†è®ºçš„æ–¹æ³•ï¼Œç”¨äºæå‡å¤æ‚ç»„åˆç³»ç»Ÿçš„å®‰å…¨æ€§ï¼›å¹¶é˜è¿°äº†è¯¥æ–¹æ³•å¦‚ä½•æ¨åŠ¨è¾“å…¥éªŒè¯ã€å®‰å…¨å»ºæ¨¡ã€æ”»å‡»é¢ç¼©å‡ï¼Œä»¥åŠæœ€ç»ˆåœ¨è½¯ä»¶è®¾è®¡ä¸ç¼–ç¨‹æ–¹æ³•è®ºæ–¹é¢çš„è¿›æ­¥ã€‚æˆ‘ä»¬å¼•ç”¨äº†åŸºäºå¸¸è§åè®®ä¸­çœŸå®å®‰å…¨æ¼æ´çš„å®ä¾‹ï¼Œè¿™äº›åè®®ä»£è¡¨äº†ä¸åŒå¤æ‚åº¦çš„åè®®ç±»åˆ«ã€‚æ­¤å¤–ï¼ŒåŸºäºæˆ‘ä»¬å¯¹å½¢å¼è¯­æ³•åœ¨å®‰å…¨ä¸­æ‰€æ‰®æ¼”è§’è‰²çš„æ„æƒ³ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€ç§æ¼æ´åˆ©ç”¨å¼€å‘æŠ€æœ¯çš„å½¢å¼åŒ–æè¿°â€”â€”è¯­æ³•æ ‘å·®åˆ†æ”»å‡»ï¼ˆparse tree differential attackï¼‰ã€‚è¿™äº›æ´è§ä¸ºæœªæ¥è½¯ä»¶å®¡è®¡æŠ€æœ¯çš„è¿›æ­¥é“ºå¹³äº†é“è·¯ï¼Œè¿™äº›æŠ€æœ¯å¯åº”ç”¨äºé™æ€ä¸åŠ¨æ€äºŒè¿›åˆ¶åˆ†æã€æ¨¡ç³Šæµ‹è¯•ï¼ˆfuzzingï¼‰ã€ä»¥åŠé€šç”¨çš„é€†å‘å·¥ç¨‹ä¸æ¼æ´åˆ©ç”¨å¼€å‘ã€‚ Our work provides a foundation for verifying critical implementation components with considerably less burden to developers than is offered by the current state of the art. It additionally offers a rich basis for further exploration in the areas of offensive analysis and, conversely, automated defense tools and techniques. æˆ‘ä»¬çš„å·¥ä½œä¸ºéªŒè¯å…³é”®å®ç°ç»„ä»¶å¥ å®šäº†åŸºç¡€ï¼Œç›¸æ¯”ç°æœ‰æŠ€æœ¯ï¼Œæ˜¾è‘—å‡è½»äº†å¼€å‘äººå‘˜çš„è´Ÿæ‹…ã€‚æ­¤å¤–ï¼Œè¯¥å·¥ä½œä¹Ÿä¸ºæ”»å‡»æ€§åˆ†æä»¥åŠï¼ˆä¸ä¹‹ç›¸å¯¹çš„ï¼‰è‡ªåŠ¨åŒ–é˜²å¾¡å·¥å…·ä¸æŠ€æœ¯é¢†åŸŸçš„è¿›ä¸€æ­¥æ¢ç´¢æä¾›äº†ä¸°å¯Œçš„åŸºç¡€ã€‚ This report is divided into two parts. In Part I we address the formalisms and their applications; in Part II we discuss the general implications and recommendations for protocol and software design that follow from our formal analysis. æœ¬æŠ¥å‘Šåˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ã€‚ç¬¬ä¸€éƒ¨åˆ†é˜è¿°å½¢å¼åŒ–æ–¹æ³•åŠå…¶åº”ç”¨ï¼›ç¬¬äºŒéƒ¨åˆ†åˆ™è®¨è®ºåŸºäºæˆ‘ä»¬å½¢å¼åŒ–åˆ†æå¾—å‡ºçš„ã€å…³äºåè®®ä¸è½¯ä»¶è®¾è®¡çš„æ€»ä½“å½±å“ä¸å»ºè®®ã€‚ 1. ä»‹ç» Composition is the primary engineering means of complex system construction. No matter what other engineering approaches or design patterns are applied, the economic reality is that a complex computing system will ultimately be pulled together from components made by different people and groups of people. ç»„åˆæ˜¯æ„å»ºå¤æ‚ç³»ç»Ÿçš„ä¸»è¦å·¥ç¨‹æ‰‹æ®µã€‚æ— è®ºé‡‡ç”¨ä½•ç§å…¶ä»–å·¥ç¨‹æ–¹æ³•æˆ–è®¾è®¡æ¨¡å¼ï¼Œç°å®æƒ…å†µæ˜¯ï¼Œä¸€ä¸ªå¤æ‚çš„è®¡ç®—ç³»ç»Ÿæœ€ç»ˆéƒ½å°†ç”±ä¸åŒäººå‘˜æˆ–å›¢é˜Ÿå¼€å‘çš„ç»„ä»¶ç»„è£…è€Œæˆã€‚ For the traditional division of a system into hardware, firmware, and software, and of software into device drivers, generic OS kernel and its sub-layers, and various application software stacks and libraries the fact of this composition is so obvious that it is commonly dismissed as trivial; how else can one build modern computers and modern software if not in a modular way? Moreover, modularity is supposed to be good for security and reliability, because without them programming would be intractable. åœ¨ä¼ ç»Ÿç³»ç»Ÿåˆ†å±‚ï¼ˆç¡¬ä»¶ã€å›ºä»¶ã€è½¯ä»¶ï¼‰ä»¥åŠè½¯ä»¶åˆ†å±‚ï¼ˆè®¾å¤‡é€šç”¨æ“ä½œç³»ç»Ÿå†…æ ¸åŠå…¶å­å±‚ã€å„ç±»åº”ç”¨è½¯ä»¶æ ˆä¸åº“ï¼‰çš„èƒŒæ™¯ä¸‹ï¼Œè¿™ç§ç»„åˆçš„äº‹å®å¦‚æ­¤æ˜¾è€Œæ˜“è§ï¼Œä»¥è‡³äºå¸¸è¢«è§†ä¸ºå¾®ä¸è¶³é“è€Œè¢«å¿½ç•¥ï¼›è‹¥éé‡‡ç”¨æ¨¡å—åŒ–æ–¹å¼ï¼Œè¿˜èƒ½å¦‚ä½•æ„å»ºç°ä»£è®¡ç®—æœºä¸è½¯ä»¶ï¼Ÿæ­¤å¤–ï¼Œæ¨¡å—åŒ–ç†åº”æœ‰ç›Šäºå®‰å…¨æ€§ä¸å¯é æ€§ï¼Œå› ä¸ºç¼ºä¹å®‰å…¨æ€§ä¸å¯é æ€§ï¼Œç¼–ç¨‹å°†å˜å¾—éš¾ä»¥å¤„ç†ã€‚ However, doing composition securely has emerged as the primary challenge to secure system construction. Security practitioners know that interfaces are attack targets of choice, and that vulnerabilities are often caused by unexpected interactions of features across components; yet the reasons for this are elusive (except perhaps the attackerâ€™s desire for reliable execution of their exploits, which leads them to target the best-described parts of systems with tractable state; still, this does not explain our collective inability to design systems without unwanted feature interactions). ç„¶è€Œï¼Œå®ç°å®‰å…¨çš„ç»„åˆå·²æˆä¸ºæ„å»ºå®‰å…¨ç³»ç»Ÿçš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚å®‰å…¨ä»ä¸šè€…æ·±çŸ¥æ¥å£æ˜¯æ”»å‡»è€…çš„é¦–é€‰ç›®æ ‡ï¼Œè€Œæ¼æ´å¾€å¾€æºäºç»„ä»¶é—´åŠŸèƒ½çš„éé¢„æœŸäº¤äº’ã€‚ä½†å…¶æ·±å±‚åŸå› ä»éš¾ä»¥æ‰æ‘¸ï¼ˆæˆ–è®¸å¯å½’å› äºæ”»å‡»è€…è¿½æ±‚æ¼æ´åˆ©ç”¨çš„å¯é æ‰§è¡Œï¼Œæ•…å€¾å‘äºé’ˆå¯¹ç³»ç»ŸçŠ¶æ€å¯æ§ã€æ–‡æ¡£å®Œå¤‡çš„éƒ¨åˆ†ï¼Œä½†è¿™ä»æ— æ³•è§£é‡Šä¸ºä½•æˆ‘ä»¬å§‹ç»ˆéš¾ä»¥è®¾è®¡å‡ºå®Œå…¨è§„é¿éé¢„æœŸåŠŸèƒ½äº¤äº’çš„ç³»ç»Ÿï¼‰ã€‚ In this paper we argue that we need a new, stronger theoretic understanding of computational unitsâ€™ composition and of their underlying properties that make it empirically hard to â€œget it rightâ€, i.e., design systems without vulnerabilities caused by composition. åœ¨æœ¬è®ºæ–‡ä¸­ï¼Œæˆ‘ä»¬ä¸»å¼ éœ€è¦å¯¹è®¡ç®—å•å…ƒçš„ç»„æˆåŠå…¶åº•å±‚å±æ€§å»ºç«‹ä¸€ç§æ–°çš„ã€æ›´å¼ºçš„ç†è®ºè§£é‡Šï¼Œæ­£æ˜¯è¿™äº›å±æ€§ä½¿å¾—å®è·µä¸­éš¾ä»¥â€œå®ç°å®Œç¾â€â€”â€”å³è®¾è®¡å‡ºä¸å­˜åœ¨ç”±ç»„åˆå¼•å‘æ¼æ´çš„ç³»ç»Ÿã€‚ We show that there are strong computational-theoretic and formal language-theoretic reasons for the challenges of secure composition, and chart design principles to reduce these challenges. In particular, we show that the hard challenges of safe input handling and secure composition arise due to the underlying theoretically hard or unsolvable (i.e., undecidable) problems that certain protocol designs and implementations essentially require to solve in order to secure them. We posit that the (unwitting) introduction of such problems in the design stage explains the extreme propensity of certain protocols and message formats to yield a seemingly endless stream of â€œ0-dayâ€ vulnerabilities despite efforts to stem it, and the empirical hopelessness of â€œfixingâ€ these protocols and message formats without a fundamental redesign. æˆ‘ä»¬æ­ç¤ºäº†å®‰å…¨ç»„åˆé¢ä¸´çš„æŒ‘æˆ˜ï¼Œå­˜åœ¨æ·±å±‚çš„è®¡ç®—ç†è®ºå±‚é¢åŠå½¢å¼è¯­è¨€ç†è®ºå±‚é¢çš„åŸå› ï¼Œå¹¶è§„åˆ’äº†é™ä½è¿™äº›æŒ‘æˆ˜çš„è®¾è®¡åŸåˆ™ã€‚å…·ä½“è€Œè¨€ï¼Œå®‰å…¨è¾“å…¥å¤„ç†ä¸å®‰å…¨ç»„åˆé¢ä¸´çš„ä¸¥å³»æŒ‘æˆ˜ï¼ŒæºäºæŸäº›åè®®è®¾è®¡ä¸å®ç°æœ¬è´¨ä¸Šå¿…é¡»è§£å†³çš„åº•å±‚ç†è®ºéš¾é¢˜â€”â€”è¿™äº›é—®é¢˜åœ¨ç†è®ºä¸Šæœ¬å°±éš¾ä»¥è§£å†³ç”šè‡³æ— è§£ï¼ˆå³ä¸å¯åˆ¤å®šï¼‰ã€‚æˆ‘ä»¬è®¤ä¸ºï¼Œè®¾è®¡é˜¶æ®µï¼ˆæ— æ„çš„ï¼‰å¼•å…¥æ­¤ç±»é—®é¢˜ï¼Œå¯¼è‡´ç‰¹å®šåè®®å’Œæ¶ˆæ¯æ ¼å¼ææ˜“è¡ç”Ÿçœ‹ä¼¼æ— æ­¢å¢ƒçš„é›¶æ—¥æ¼æ´é—®é¢˜ï¼ˆå°½ç®¡äººä»¬åŠªåŠ›éåˆ¶ï¼‰ã€‚ä¸”åœ¨ç¼ºä¹æ ¹æœ¬æ€§é‡æ„çš„æƒ…å†µä¸‹ï¼Œå¯¹è¿™äº›åè®®ä¸æ¶ˆæ¯æ ¼å¼è¿›è¡Œâ€œä¿®è¡¥â€åœ¨å®è·µä¸­æ˜¯å¾’åŠ³çš„ã€‚ We also chart ways to avoid such designs prone to turning into security nightmares for future Internet protocols. Empirically, attempts to solve an engineering problem that implies a â€œgood enoughâ€ (or â€œ80%20%â€) solution to the underlying undecidable theory problem are doomed to frustration and failure, which manifests in many ways, such as no amount of testing apparently sufficing to get rid of bugs, or the overwhelming complexity and not-quite-correct operation of the automation or detection tools created to deal with the problem. Thus, avoidingsuch problems in the first place (at the design stage) saves both misinvestment of programming effort and operational costs. æˆ‘ä»¬è¿˜è§„åˆ’äº†é¿å…æ­¤ç±»è®¾è®¡çš„è·¯å¾„ï¼Œä»¥é˜²æ­¢å…¶æ¼”å˜ä¸ºæœªæ¥äº’è”ç½‘åè®®ä¸­çš„å®‰å…¨éšæ‚£ã€‚å®è·µè¡¨æ˜ï¼Œè‹¥å·¥ç¨‹é—®é¢˜æœ¬è´¨ä¸Šéœ€è§£å†³ä¸å¯åˆ¤å®šçš„ç†è®ºé—®é¢˜ï¼Œé‚£ä¹ˆè¯•å›¾ä»¥â€œè¶³å¤Ÿå¥½â€ï¼ˆå¦‚â€œ80%å¯¹æ¯”20%â€ï¼‰çš„æ–¹æ¡ˆåº”å¯¹æ—¶ï¼Œä¹Ÿå¾€å¾€ä»¥å¤±è´¥å‘Šç»ˆã€‚å…¶è¡¨ç°å½¢å¼å¤šæ ·ï¼šä¾‹å¦‚æ— è®ºå¤šå°‘æµ‹è¯•å‡æ— æ³•æ ¹é™¤ç¼ºé™·ï¼Œæˆ–ä¸ºåº”å¯¹è¯¥é—®é¢˜å¼€å‘çš„è‡ªåŠ¨åŒ–æ£€æµ‹å·¥å…·å¤æ‚ç¨‹åº¦æé«˜ä¸”è¿è¡Œå¹¶éå®Œå…¨æ­£ç¡®ã€‚å› æ­¤ï¼Œåœ¨è®¾è®¡é˜¶æ®µé¢„å…ˆè§„é¿æ­¤ç±»é—®é¢˜ï¼Œæ—¢å¯é¿å…ç¼–ç¨‹èµ„æºçš„è¿‡åº¦æŠ•å…¥ï¼Œä¹Ÿèƒ½é™ä½è¿è¥æˆæœ¬ã€‚ Our argument focuses on the application of fundamental decidability results to the two basic challenges of composed and distributed system construction due to communication between components: safely accepting and handling inputs in every component, and identical interpretation of messages passed between components at every endpoint. In particular, we consider the following two perspectives on composition: æˆ‘ä»¬çš„è®ºç‚¹ä¸»è¦é›†ä¸­åœ¨å°†åŸºæœ¬å¯åˆ¤å®šæ€§ç»“æœåº”ç”¨äºç”±ç»„ä»¶é—´é€šä¿¡å¼•èµ·çš„å¤åˆå’Œåˆ†å¸ƒå¼ç³»ç»Ÿæ„å»ºçš„ä¸¤ä¸ªåŸºæœ¬æŒ‘æˆ˜ï¼šåœ¨æ¯ä¸ªç»„ä»¶ä¸­å®‰å…¨åœ°æ¥å—å’Œå¤„ç†è¾“å…¥ï¼Œä»¥åŠåœ¨æ¯ä¸ªç«¯ç‚¹ä¸Šå¯¹ç»„ä»¶é—´ä¼ é€’çš„æ¶ˆæ¯è¿›è¡Œç›¸åŒçš„è§£é‡Šã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬è€ƒè™‘äº†ä»¥ä¸‹ä¸¤ä¸ªå…³äºç»„åˆçš„è§‚ç‚¹ï¼š Single-component perspective: A component in a complex system must accept inputs or messages across one or more interfaces. This creates an attack surface, leveraged by an absolute majority of exploitation techniques. We discuss hardening the attack surface of each component against malicious crafted inputs, so that a component is capable of rejecting them without losing integrity and exhibiting unexpected behaviorâ€” in short, without being exploited. Multi-component perspective: As components exchange messages, they must ensure that, despite possible implementation differences, they interpret the messages identi-cally. Although this requirement appears to be trivially necessary for correct opera-tion, in reality different implementations of a protocol by different components produce variations, or mutually intelligible dialects, with message semantic differences masked(and therefore ignored) in non-malicious exchanges. A smaller but important class of attack techniques leverages such differences, and can lead to devastating attacks such as those on X.509 and ASN.1 discussed in this paper. å•ç»„ä»¶è§†è§’ï¼šå¤æ‚ç³»ç»Ÿä¸­çš„ä¸€ä¸ªç»„ä»¶å¿…é¡»é€šè¿‡ä¸€ä¸ªæˆ–å¤šä¸ªæ¥å£æ¥å—è¾“å…¥æˆ–æ¶ˆæ¯ã€‚è¿™ä¼šåˆ›å»ºä¸€ä¸ªæ”»å‡»é¢ï¼Œè¢«ç»å¤§å¤šæ•°åˆ©ç”¨æŠ€æœ¯æ‰€åˆ©ç”¨ã€‚æˆ‘ä»¬è®¨è®ºäº†å¦‚ä½•åŠ å›ºæ¯ä¸ªç»„ä»¶çš„æ”»å‡»é¢ä»¥æŠµå¾¡æ¶æ„åˆ¶ä½œçš„è¾“å…¥ï¼Œä»è€Œä½¿ç»„ä»¶èƒ½å¤Ÿåœ¨ä¸å¤±å»å®Œæ•´æ€§å’Œè¡¨ç°å‡ºæ„å¤–è¡Œä¸ºçš„æƒ…å†µä¸‹æ‹’ç»è¿™äº›è¾“å…¥â€”â€”ç®€è€Œè¨€ä¹‹ï¼Œä¸ä¼šè¢«åˆ©ç”¨ã€‚ å¤šç»„ä»¶è§†è§’ï¼šå½“ç»„ä»¶äº¤æ¢æ¶ˆæ¯æ—¶ï¼Œå®ƒä»¬å¿…é¡»ç¡®ä¿å°½ç®¡å¯èƒ½å­˜åœ¨å®ç°å·®å¼‚ï¼Œä½†å®ƒä»¬å¯¹æ¶ˆæ¯çš„è§£é‡Šæ˜¯ç›¸åŒçš„ã€‚è™½ç„¶è¿™ä¸ªè¦æ±‚çœ‹èµ·æ¥å¯¹äºæ­£ç¡®æ“ä½œæ¥è¯´æ˜¯å¾®ä¸è¶³é“çš„ï¼Œä½†å®é™…ä¸Šä¸åŒç»„ä»¶å¯¹åè®®çš„ä¸åŒå®ç°ä¼šäº§ç”Ÿå˜åŒ–ï¼Œæˆ–è€…ç›¸äº’å¯ç†è§£çš„æ–¹è¨€ï¼Œå…¶ä¸­æ¶ˆæ¯è¯­ä¹‰å·®å¼‚åœ¨éæ¶æ„äº¤æ¢ä¸­è¢«æ©ç›–ï¼ˆå› æ­¤è¢«å¿½ç•¥ï¼‰ã€‚ä¸€å°éƒ¨åˆ†ä½†é‡è¦çš„æ”»å‡»æŠ€æœ¯åˆ©ç”¨äº†è¿™ç§å·®å¼‚ï¼Œå¹¶å¯èƒ½å¯¼è‡´æ¯ç­æ€§çš„æ”»å‡»ï¼Œä¾‹å¦‚æœ¬æ–‡è®¨è®ºçš„å¯¹X.509å’ŒASN.1çš„æ”»å‡»ã€‚ The importance of these requirements is an empirical fact of the Internet security experience(cf.[1, 2, 3]), which our paper puts in solid theory perspective. We then elaborate the general principles of protocol design that follow from our analysis. è¿™äº›è¦æ±‚çš„é‡è¦æ€§æ˜¯äº’è”ç½‘å®‰å…¨ç»éªŒçš„å®è¯äº‹å®ï¼ˆå‚è§[1, 2, 3]ï¼‰ï¼Œæˆ‘ä»¬çš„è®ºæ–‡ä»åšå®çš„ç†è®ºè§’åº¦è¿›è¡Œäº†é˜è¿°ã€‚ç„¶åï¼Œæˆ‘ä»¬è¯¦ç»†é˜è¿°äº†éµå¾ªæˆ‘ä»¬åˆ†æçš„åè®®è®¾è®¡çš„ä¸€èˆ¬åŸåˆ™ã€‚ æœ¬æ–‡ç»“æ„ Our presentation consists of two parts. In Part I we make the case for formal language-theoretic approach to security, and show the direct relevance of various formalisms to prac-tical, state-of-the-art classes of exploits and defences. In Part II we change tack and address protocols designers, developers, and security auditors with a set of recommendations derived from our formal analysis but formulated informally and accessibly. Readers interested in our recommendations may skip the formal arguments in Part I and go straight to Part IIâ€™s for their summary. æˆ‘ä»¬çš„æŠ¥å‘Šåˆ†ä¸ºä¸¤éƒ¨åˆ†ã€‚åœ¨ç¬¬ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬ä¸ºå®‰å…¨çš„æ­£å¼è¯­è¨€ç†è®ºæ–¹æ³•è¿›è¡Œè¾©æŠ¤ï¼Œå¹¶å±•ç¤ºå„ç§å½¢å¼ä¸»ä¹‰ä¸å®è·µä¸­çš„ã€æœ€å…ˆè¿›çš„æ”»å‡»å’Œé˜²å¾¡ç±»åˆ«çš„ç›´æ¥ç›¸å…³æ€§ã€‚åœ¨ç¬¬äºŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬æ”¹å˜ç­–ç•¥ï¼Œå‘åè®®è®¾è®¡è€…ã€å¼€å‘è€…å’Œå®‰å…¨å®¡è®¡å‘˜æå‡ºä¸€ç³»åˆ—å»ºè®®ï¼Œè¿™äº›å»ºè®®æºè‡ªæˆ‘ä»¬çš„æ­£å¼åˆ†æï¼Œä½†ä»¥éæ­£å¼ä¸”æ˜“äºç†è§£çš„æ–¹å¼è¡¨è¿°ã€‚å¯¹æˆ‘ä»¬çš„å»ºè®®æ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è·³è¿‡ç¬¬ä¸€éƒ¨åˆ†çš„å½¢å¼è®ºè¯ï¼Œç›´æ¥é˜…è¯»ç¬¬äºŒéƒ¨åˆ†çš„æ€»ç»“ã€‚ We start with the motivation of our approach in Section 2 and review the necessary background formalisms in Section 3. æˆ‘ä»¬åœ¨ç¬¬2èŠ‚ä¸­ä»‹ç»äº†æˆ‘ä»¬çš„æ–¹æ³•çš„åŠ¨æœºï¼Œå¹¶åœ¨ç¬¬3èŠ‚ä¸­å›é¡¾äº†å¿…è¦çš„èƒŒæ™¯å½¢å¼ã€‚ Then in Section 4 we explain how these general formalisms apply to exploitation of computing systems, and illustrate this application for several well-known classes of practical exploitation techniques. In doing so, we connect the corresponding classes of attacks with formal language properties of targeted data structures, which provides a novel and definitive way to analyze various suggested defences. åœ¨ç¬¬5èŠ‚ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•åº”ç”¨å½¢å¼è¯­è¨€ç†è®ºæŠ€æœ¯æ¥å®ç°ä¸¥æ ¼çš„ã€éå¯å‘å¼çš„è¾“å…¥éªŒè¯ã€‚æˆ‘ä»¬ä»SQLéªŒè¯å¼€å§‹è®¨è®ºï¼Œä½†ä¹Ÿè¡¨æ˜åŒæ ·çš„æ–¹æ³•é€‚ç”¨äºå…¶ä»–ä¸Šä¸‹æ–‡æ— å…³çš„è¯­è¨€ï¼Œå¦‚PKCS#1ï¼ˆåœ¨ç¬¬5.2èŠ‚ä¸­ï¼Œæˆ‘ä»¬è¯æ˜äº†PKCS#1ç¡®å®æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³çš„ï¼‰ã€‚æˆ‘ä»¬è¿˜è®¨è®ºäº†å…ˆå‰éªŒè¯æ–¹æ³•ä¸­çš„ç¼ºé™·ï¼Œå¹¶è¯´æ˜ä¸ºä»€ä¹ˆè¿™äº›ç¼ºé™·å¯¹å®é™…å®‰å…¨è‡³å…³é‡è¦ã€‚ The discussion of flaws leads to us Section 6, in which we present a new technique for security analysis of differences between mutually intelligible language dialects that arise from implementation differences. This technique, Parse Tree Differential Analysis, proved a powerful tool to enhance code auditing and protocol analysis. å¯¹ç¼ºé™·çš„è®¨è®ºå¼•å¯¼æˆ‘ä»¬è¿›å…¥ç¬¬6èŠ‚ï¼Œåœ¨è¿™ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°çš„æŠ€æœ¯ï¼Œç”¨äºåˆ†æå› å®ç°å·®å¼‚è€Œäº§ç”Ÿçš„ç›¸äº’å¯ç†è§£è¯­è¨€æ–¹è¨€ä¹‹é—´çš„å·®å¼‚çš„å®‰å…¨æ€§åˆ†æã€‚è¿™ç§æŠ€æœ¯ï¼Œå³è§£ææ ‘å·®å¼‚åˆ†æï¼Œè¢«è¯æ˜æ˜¯ä¸€ç§å¢å¼ºä»£ç å®¡è®¡å’Œåè®®åˆ†æçš„å¼ºå¤§å·¥å…·ã€‚ In Section 7, we show that the challenges and failures of IDSIPS, arguably the most common form of security composition, can be explained via language-theoretic computa-tional equivalence. We conclude Part I with an outline of future work. åœ¨ç¬¬7èŠ‚ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†IDSIPSçš„æŒ‘æˆ˜å’Œå¤±è´¥ï¼Œå¯ä»¥è¯´æ˜¯å®‰å…¨ç»„åˆæœ€å¸¸è§çš„å½¢å¼ï¼Œå¯ä»¥é€šè¿‡è¯­è¨€ç†è®ºè®¡ç®—ç­‰ä»·æ€§æ¥è§£é‡Šã€‚æˆ‘ä»¬ä»¥å¯¹æœªæ¥å·¥ä½œçš„æ¦‚è¿°ç»“æŸäº†ç¬¬ä¸€éƒ¨åˆ†ã€‚ In Part II we recap the observations of Part I and formulate several principles that follow from our analysis in the preceding sections, and discuss their corollaries for designing and implementing protocols securely. åœ¨ç¬¬äºŒéƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å›é¡¾äº†ç¬¬ä¸€éƒ¨åˆ†çš„è§‚å¯Ÿç»“æœï¼Œå¹¶æ ¹æ®å‰å‡ èŠ‚çš„åˆ†æåˆ¶å®šäº†å‡ ä¸ªåŸåˆ™ï¼Œè®¨è®ºäº†å®ƒä»¬å¯¹å®‰å…¨è®¾è®¡å’Œå®æ–½åè®®çš„æ¨è®ºã€‚ ç¬¬ä¸€éƒ¨åˆ†ï¼šå®‰å…¨ä¸å½¢å¼è¯­è¨€ç†è®ºä¸ºä»€ä¹ˆå®‰å…¨éœ€è¦å½¢å¼è¯­è¨€ç†è®º We posit that input verification using formal language theoretic methods â€” whether simply verifying that an input to a protocol constitutes a valid expression in the protocolâ€™s gram-mar or also verifying the semantics of input transformations â€” is an overlooked but vital component of protocol security, particularly with respect to implementations. Simply put, a protocol implementation cannot be correct unless it recognizes input correctly, and should be considered broken. æˆ‘ä»¬æå‡ºï¼Œä½¿ç”¨å½¢å¼è¯­è¨€ç†è®ºæ–¹æ³•è¿›è¡Œè¾“å…¥éªŒè¯â€”â€”æ— è®ºæ˜¯ç®€å•åœ°éªŒè¯åè®®çš„è¾“å…¥æ˜¯å¦æ„æˆåè®®è¯­æ³•ä¸­çš„æœ‰æ•ˆè¡¨è¾¾å¼ï¼Œè¿˜æ˜¯éªŒè¯è¾“å…¥è½¬æ¢çš„è¯­ä¹‰â€”â€”æ˜¯åè®®å®‰å…¨çš„ä¸€ä¸ªè¢«å¿½è§†ä½†è‡³å…³é‡è¦çš„ç»„æˆéƒ¨åˆ†ï¼Œç‰¹åˆ«æ˜¯åœ¨å®ç°æ–¹é¢ã€‚ç®€è€Œè¨€ä¹‹ï¼Œé™¤éåè®®å®ç°èƒ½å¤Ÿæ­£ç¡®è¯†åˆ«è¾“å…¥ï¼Œå¦åˆ™å®ƒå°±æ— æ³•æ­£ç¡®è¿è¡Œï¼Œå¹¶åº”è¢«è§†ä¸ºæœ‰ç¼ºé™·çš„ã€‚ Formal software verification seeks to prove certain safety(â€œnothing bad happensâ€) and liveness(â€œsomething good happens, eventuallyâ€) properties of program computations: if ev-ery computation a program can perform satisfies a particular property, the program is safe(or, respectively, live) with respect to that property[4]. Program verification in the general case is undecidable, and although many approaches to falsification and verification of properties have been developed, unsolved and unsolvable problems with the scalability and completeness of algorithmic verification have prevented formal correctness from displacing testing and code auditing as the industry gold standard for software quality assurance[5]. However, programs that implement protocols â€” that is to say, routines that operate over a well-defined input language1 â€” share one characteristic that can be leveraged to dramati-cally reduce their attack surfaces: their input languages can â€” and, we posit, should â€” in general be made decidable and can be decided in a tractable fashion. We show that this requirement of being well-specified and tractably decidable is in fact a crucial pre-requisite of secure design and, in fact, its violation is the source of much of the present-day computer insecurity. æ­£å¼è½¯ä»¶éªŒè¯æ—¨åœ¨è¯æ˜ç¨‹åºè®¡ç®—çš„æŸäº›å®‰å…¨ï¼ˆâ€œä¸ä¼šå‘ç”Ÿåäº‹â€ï¼‰å’Œæ´»æ€§ï¼ˆâ€œæœ€ç»ˆä¼šå‘ç”Ÿå¥½äº‹â€ï¼‰å±æ€§ï¼šå¦‚æœç¨‹åºå¯ä»¥æ‰§è¡Œçš„æ¯ä¸ªè®¡ç®—éƒ½æ»¡è¶³ç‰¹å®šå±æ€§ï¼Œé‚£ä¹ˆè¯¥ç¨‹åºåœ¨è¯¥å±æ€§æ–¹é¢æ˜¯å®‰å…¨çš„ï¼ˆæˆ–åˆ†åˆ«å…·æœ‰æ´»æ€§ï¼‰[4]ã€‚ä¸€èˆ¬æƒ…å†µä¸‹çš„ç¨‹åºéªŒè¯æ˜¯ä¸å¯åˆ¤å®šçš„ï¼Œå°½ç®¡å·²ç»å¼€å‘äº†è®¸å¤šå±æ€§çš„åè¯å’ŒéªŒè¯æ–¹æ³•ï¼Œä½†ç®—æ³•éªŒè¯çš„å¯æ‰©å±•æ€§å’Œå®Œæ•´æ€§çš„æœªè§£å†³å’Œæ— æ³•è§£å†³çš„é—®é¢˜é˜»ç¢äº†æ­£å¼æ­£ç¡®æ€§å–ä»£æµ‹è¯•å’Œä»£ç å®¡è®¡ä½œä¸ºè½¯ä»¶è´¨é‡ä¿è¯çš„è¡Œä¸šé»„é‡‘æ ‡å‡†[5]ã€‚ç„¶è€Œï¼Œå®ç°åè®®çš„ç¨‹åºâ€”â€”ä¹Ÿå°±æ˜¯è¯´ï¼Œæ“ä½œåœ¨æ˜ç¡®å®šä¹‰çš„è¾“å…¥è¯­è¨€ä¸Šçš„ä¾‹ç¨‹â€”â€”å…±äº«ä¸€ä¸ªç‰¹æ€§ï¼Œå¯ä»¥åˆ©ç”¨è¿™ä¸ªç‰¹æ€§æ¥æ˜¾è‘—å‡å°‘å®ƒä»¬çš„æ”»å‡»é¢ï¼šå®ƒä»¬çš„è¾“å…¥è¯­è¨€é€šå¸¸å¯ä»¥è¢«åˆ¶æˆå¯åˆ¤å®šçš„(æˆ‘ä»¬ä¸»å¼ ä¹Ÿåº”è¯¥è¿™ä¹ˆåš)ï¼Œå¹¶ä¸”å¯ä»¥ä»¥ä¸€ç§å¯è¡Œçš„æ–¹å¼è¿›è¡Œåˆ¤å®šã€‚æˆ‘ä»¬è¡¨æ˜ï¼Œè¿™ç§è¦æ±‚æ˜¯è‰¯å¥½æŒ‡å®šå’Œå¯è¡Œå¯åˆ¤å®šçš„ï¼Œå®é™…ä¸Šæ˜¯å®‰å…¨è®¾è®¡çš„å…³é”®å…ˆå†³æ¡ä»¶ï¼Œäº‹å®ä¸Šï¼Œå…¶è¿åæ˜¯å½“ä»Šè®¡ç®—æœºä¸å®‰å…¨çš„ä¸»è¦æ¥æºã€‚ Inputs to system components such as web browsers, network stacks, cryptographic pro-tocols, and databases are formally specified in standards documents, but by and large, implementationsâ€™ input handling routines parse the languages these standards specify in an ad hoc fashion. Attacks such as the Bleichenbacher PKCS#1 forgery[6, 7] show what can happen when an ad hoc input-language implementation fails to provide all the prop-erties of the input language as actually specified. In more recent work[8], we have shown that variations among implementations can be exploited to subvert the interoperation of these implementations, and that ambiguity or underspecification in a standard increases the chances of vulnerability in otherwise standards-compliant implementations. ç³»ç»Ÿç»„ä»¶çš„è¾“å…¥ï¼Œå¦‚ç½‘ç»œæµè§ˆå™¨ã€ç½‘ç»œå †æ ˆã€åŠ å¯†åè®®å’Œæ•°æ®åº“ï¼Œåœ¨æ ‡å‡†æ–‡æ¡£ä¸­è¢«æ­£å¼è§„å®šï¼Œä½†æ€»çš„æ¥è¯´ï¼Œå®ç°çš„è¾“å…¥å¤„ç†ç¨‹åºä»¥ä¸€ç§ä¸´æ—¶çš„æ–¹å¼è§£æè¿™äº›æ ‡å‡†æ‰€è§„å®šçš„è¯­è¨€ã€‚è¯¸å¦‚Bleichenbacher PKCS#1ä¼ªé€ [6, 7]ç­‰æ”»å‡»è¡¨æ˜ï¼Œå½“ä¸€ä¸ªä¸´æ—¶çš„è¾“å…¥è¯­è¨€å®ç°æœªèƒ½æä¾›å®é™…æŒ‡å®šçš„è¾“å…¥è¯­è¨€çš„æ‰€æœ‰å±æ€§æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚åœ¨æœ€è¿‘çš„å·¥ä½œ[8]ä¸­ï¼Œæˆ‘ä»¬å·²ç»è¯æ˜ï¼Œå®ç°ä¹‹é—´çš„å·®å¼‚å¯ä»¥è¢«åˆ©ç”¨æ¥ç ´åè¿™äº›å®ç°çš„äº’æ“ä½œæ€§ï¼Œå¹¶ä¸”æ ‡å‡†ä¸­çš„æ¨¡ç³Šæˆ–æœªå……åˆ†è§„å®šä¼šå¢åŠ å…¶ä»–ç¬¦åˆæ ‡å‡†çš„å®ç°ä¸­å‡ºç°æ¼æ´çš„å¯èƒ½æ€§ã€‚ On this basis, we argue that â€œmutually intelligible dialectsâ€ of a protocol cannot make guarantees about their operation because the problem $Equivalent(L(G) L(H))$ is unde-cidable when G and H are grammars more powerful than deterministic context-free[9, 10]. We also observe that systems that consist of more than one component have inherent, de facto â€œdesign contractsâ€ for how their components interact, but generally do not enforce these contracts; SQL injection attacks(hereafter SQLIA), for instance, occur when an at-tacker presents a database with an input query that is valid for the database in isolation, but invalid within the context of the databaseâ€™s role in a larger application. åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬è®¤ä¸ºåè®®çš„â€œç›¸äº’å¯ç†è§£æ–¹è¨€â€æ— æ³•å¯¹å…¶æ“ä½œåšå‡ºä¿è¯ï¼Œå› ä¸ºå½“Gå’ŒHæ˜¯æ¯”ç¡®å®šæ€§ä¸Šä¸‹æ–‡æ— å…³æ›´å¼ºå¤§çš„è¯­æ³•æ—¶ï¼Œé—®é¢˜ $Equivalent(L(G) L(H))$ æ˜¯ä¸å¯åˆ¤å®šçš„[9, 10]ã€‚æˆ‘ä»¬è¿˜è§‚å¯Ÿåˆ°ï¼Œç”±å¤šä¸ªç»„ä»¶ç»„æˆçš„ç³»ç»Ÿå…·æœ‰å›ºæœ‰çš„ã€äº‹å®ä¸Šçš„â€œè®¾è®¡åˆåŒâ€ï¼Œè§„å®šäº†å…¶ç»„ä»¶å¦‚ä½•äº¤äº’ï¼Œä½†é€šå¸¸ä¸å¼ºåˆ¶æ‰§è¡Œè¿™äº›åˆåŒï¼›ä¾‹å¦‚ï¼ŒSQLæ³¨å…¥æ”»å‡»ï¼ˆä»¥ä¸‹ç®€ç§°SQLIAï¼‰å‘ç”Ÿåœ¨æ”»å‡»è€…å‘æ•°æ®åº“æä¾›ä¸€ä¸ªåœ¨å­¤ç«‹çŠ¶æ€ä¸‹å¯¹æ•°æ®åº“æœ‰æ•ˆçš„è¾“å…¥æŸ¥è¯¢ï¼Œä½†åœ¨æ•°æ®åº“åœ¨æ›´å¤§åº”ç”¨ç¨‹åºä¸­çš„è§’è‰²èƒŒæ™¯ä¸‹æ— æ•ˆçš„æƒ…å†µä¸‹ã€‚"},{"title":"notedemo","path":"/2025/07/18/notedemo/","content":"è¿™æ˜¯ä¸€ç¯‡ç¬”è®°ï¼Œç”¨äºæµ‹è¯•çš„"},{"title":"page03","path":"/2025/07/17/page03/","content":"äºŒçº§comments: enable: true # æŒ‡å®šçš„æ’ä»¶ï¼Œéœ€è¦åŒæ—¶è®¾ç½®å¯¹åº”æ’ä»¶çš„å¿…è¦å‚æ•° # The specified plugin needs to set the necessary parameters at the same time # Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis type: giscus {è¿™æ˜¯ä¸€ä¸ªå‹æƒ…é“¾æ¥} æ™®é€šçš„æ²¡æœ‰å‹¾é€‰çš„å¤é€‰æ¡† æ™®é€šçš„å·²å‹¾é€‰çš„å¤é€‰æ¡† æ˜¾ç¤ºä¸ºåŠ å·çš„ç»¿è‰²çš„å·²å‹¾é€‰çš„å¤é€‰æ¡† æ˜¾ç¤ºä¸ºå‡å·çš„é»„è‰²çš„å·²å‹¾é€‰çš„å¤é€‰æ¡† æ˜¾ç¤ºä¸ºä¹˜å·çš„çº¢è‰²çš„å·²å‹¾é€‰çš„å¤é€‰æ¡† $$\\sum_{i0}^n i^2 \\frac{(n^2+n)(2n+1)}{6}$$ graph LR A(Section A) -->|option 1| B(Section A) B -->|option 2| C(Section C) è¿™æ˜¯ä½¿ç”¨markdown é»˜è®¤çš„å¼•ç”¨æ ¼å¼ è¿™æ˜¯ä½¿ç”¨ blockquote æ ‡ç­¾çš„ä¾‹å­ çƒ­é—¨è¯é¢˜ ç‰¹åˆ«å¼•ç”¨ Xä¸å¸¦æ‘˜è¦çš„æ ·å¼ï¼š https://matrixye.github.io/%3Chttps:/hexo.io/docs/%3E Xå¸¦æ‘˜è¦çš„æ ·å¼ï¼š https://matrixye.github.io/%3Chttps:/hexo.io/docs/%3E æ¢ç´¢ O1 2077å¹´çš„å°ç›®æ ‡ï¼šå®Œæˆ Volantis 6.0 å¹¶å‘å¸ƒä¸Šçº¿ æ¥è‡ª2077å¹´æœ«çš„å¤ç›˜ï¼šå·²ã€ŠåŸºæœ¬ã€‹å®ç°ç›®æ ‡ æ­£å¸¸ 44% KR1 é‡æ„ tag-plugins å’Œ wiki ç³»ç»Ÿ å½“ KR è¿›åº¦ä¸º 100% æ—¶ï¼Œæ ‡ç­¾é»˜è®¤æ˜¾ç¤ºä¸º å·²å®Œæˆå½“ KR æœªè®¾ç½®è¿›åº¦æ—¶ï¼Œé»˜è®¤ä¸º 0%å½“ O æœªè®¾ç½®è¿›åº¦æ—¶ï¼Œåˆ™æ˜¾ç¤ºæ‰€æœ‰ KR è¿›åº¦å¹³å‡å€¼ æ­£å¸¸ 99% KR2 å®Œæˆä¸»è¦é¡µé¢è®¾è®¡ç¨¿ å°æç¤º1å°æç¤º2æ‚¨å¯ä»¥åœ¨ _config.yml æ–‡ä»¶ä¸­ä¿®æ”¹æ ‡ç­¾çš„é¢œè‰²å’Œæ–‡æ¡ˆæ‚¨å¯ä»¥åœ¨ _config.yml æ–‡ä»¶ä¸­å¢åŠ ä»»æ„çš„æ ‡ç­¾é…ç½® å»¶æœŸ 90% KR3 å®Œæˆå‰ç½®å‡†å¤‡å·¥ä½œï¼ˆå¦‚æœä½ çŸ¥é“ç­”æ¡ˆï¼Œè¯·åœ¨ç•™è¨€åŒºå¸®å¸®æˆ‘ï¼ğŸ¥¹ï¼‰ åœ¨å’¸æ°´å’Œæµ·æ»©ä¹‹é—´æ‰¾ä¸€äº©åœ°æ±‚å‡ºåœ†å‘¨ç‡å15ä½æ‰¾å‡ºå®‡å®™çš„ç»ˆæé€»è¾‘å»åœ°ç‹±é‡Œèµ°ä¸¤æ­¥ æœªå®Œæˆ -12% KR-4 å¼€å‘ã€æµ‹è¯•å’Œå‘å¸ƒ æ”¯æŒåµŒå¥—æ’å…¥å›¾ç‰‡ç­‰å…¶å®ƒç®€å•ç»„ä»¶ é£é™© 0% è¿™æ˜¯ é«˜æ–¯æ¨¡ç³Š æ ‡ç­¾ è¿™æ˜¯ å¯†ç  æ ‡ç­¾ è¿™æ˜¯ ä¸‹åˆ’çº¿ æ ‡ç­¾ è¿™æ˜¯ ç€é‡å· æ ‡ç­¾ è¿™æ˜¯ æ³¢æµªçº¿ æ ‡ç­¾ è¿™æ˜¯ åˆ é™¤çº¿ æ ‡ç­¾ è¿™æ˜¯ ä¸Šè§’æ ‡ æ ‡ç­¾ è¿™æ˜¯ ä¸‹è§’æ ‡ æ ‡ç­¾ è¿™æ˜¯ é”®ç›˜æ ·å¼ æ ‡ç­¾ï¼Œè¯•ä¸€è¯•ï¼š âŒ˜ + D è¡¨æƒ…åŒ… æŠ•ç¥¨Stellar æ˜¯æœ€å¥½çš„ hexo ä¸»é¢˜å—ï¼Ÿ 0 0 æ—¶é—´çº¿ç¬¬ä¸€æ­¥ï¼šæ‰“å¼€ GitHubæ‰“å¼€ Stellar çš„ GitHub é¡µé¢ã€‚ç¬¬äºŒæ­¥ï¼šç‚¹å‡» Starå¦‚æœå‘ç°å³ä¸Šè§’çš„ Star è¿˜æ²¡ç‚¹äº®ï¼Œå°±ç‚¹äº®å®ƒï¼ ä»£ç def hello(): print(hello world!) å¤šæ ‡ç­¾é¡µå›¾ç‰‡ä»£ç å—è¡¨æ ¼let x = 123print(hello world) a b c a1 b1 c1 a2 b2 c2","tags":["åŒºå—é“¾","bitcoin"]},{"title":"firstpage","path":"/2025/07/17/firstpage/","content":"æ ‡é¢˜æµ‹è¯•æ–‡æ¡£ äºŒçº§æ ‡é¢˜ aaaa bbbb cccc dedede dedede dedede thisi is XXXXX","tags":["bitcoin"]},{"title":"Hello World","path":"/2025/07/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new posthexo new My New Post More info: Writing Run serverhexo server More info: Server Generate static fileshexo generate More info: Generating Deploy to remote siteshexo deploy More info: Deployment","tags":["other"]}]